use std::{
    sync::{Arc, Mutex},
    time::SystemTime,
};

use futures_util::Stream;
use serde::Deserialize;
use uuid::Uuid;

#[cfg_attr(test, double_trait::dummies)]
pub trait ConversationApi: Sized {
    fn messages(self) -> impl Stream<Item = Message> + Send + 'static;
    fn add_message(&self, message: NewMessage);
}

#[derive(Clone)]
pub struct ConversationService {
    messages: Arc<Mutex<Vec<Message>>>,
}

impl ConversationService {
    pub fn new() -> Self {
        ConversationService {
            messages: Arc::new(Mutex::new(Vec::new())),
        }
    }
}

impl ConversationApi for ConversationService {
    fn messages(self) -> impl Stream<Item = Message> + Send + 'static {
        let messages = self.messages.lock().unwrap().clone();
        tokio_stream::iter(messages)
    }

    fn add_message(
        &self,
        NewMessage {
            id,
            sender,
            content,
        }: NewMessage,
    ) {
        let message = Message {
            id,
            sender,
            content,
            timestamp: SystemTime::now(),
        };
        let mut messages = self.messages.lock().unwrap();
        messages.push(message);
    }
}

/// A message as it is stored and represented as part of a conversation.
#[derive(Clone)]
pub struct Message {
    /// Sender generated unique identifier for the message. It is used to recover from errors
    /// sending messages. It also a key for the UI to efficiently update data structures then
    /// rendering messages.
    pub id: Uuid,
    /// Author of the message
    pub sender: String,
    /// Text content of the message. I.e. the actual message
    pub content: String,
    /// Timestamp when the message has been received by the server.
    pub timestamp: SystemTime,
}

/// A message as it is created by the frontend and sent to the server. It is not added to the
/// conversation yet, and does not have a timestamp.
#[derive(Deserialize, PartialEq, Eq, Debug)]
pub struct NewMessage {
    /// The uuid is generated by the client in order to be able to send messages idempotently.
    /// Wether they have been successfully received by the server and added to the conversation or
    /// not.
    pub id: Uuid,
    /// Author of the message
    pub sender: String,
    /// Text content of the message. I.e. the actual message
    pub content: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use futures_util::StreamExt;

    #[tokio::test]
    async fn messages_are_added_and_read_in_order() {
        // Given
        let id_1: Uuid = "019c0ab6-9d11-75ef-ab02-60f070b1582a".parse().unwrap();
        let msg_1 = NewMessage {
            id: id_1.clone(),
            sender: "Alice".to_string(),
            content: "One".to_string(),
        };
        let id_2: Uuid = "019c0ab6-9d11-7a5b-abde-cb349e5fd995".parse().unwrap();
        let msg_2 = NewMessage {
            id: id_2.clone(),
            sender: "Bob".to_string(),
            content: "Two".to_string(),
        };
        let conversation = ConversationService::new();

        // When
        conversation.add_message(msg_1);
        conversation.add_message(msg_2);
        let mut messages = conversation.messages();

        // Then
        let first = messages.next().await.expect("First message should exist");
        assert_eq!(first.id, id_1);
        assert_eq!(first.sender, "Alice");
        assert_eq!(first.content, "One");

        let second = messages.next().await.expect("Second message should exist");
        assert_eq!(second.id, id_2);
        assert_eq!(second.sender, "Bob");
        assert_eq!(second.content, "Two");
    }
}
