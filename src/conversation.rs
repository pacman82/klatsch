use std::{
    sync::{Arc, Mutex},
    time::SystemTime,
};

use futures_util::Stream;
use serde::Deserialize;
use tokio::{
    sync::{mpsc, oneshot},
    task::JoinHandle,
};
use uuid::Uuid;

#[cfg_attr(test, double_trait::dummies)]
pub trait Conversation: Sized {
    fn messages(self) -> impl Future<Output = impl Stream<Item = Message> + Send> + Send;
    fn add_message(&self, message: NewMessage);
}

pub struct ConversationRuntime {
    messages: Arc<Mutex<Vec<Message>>>,
    sender: mpsc::Sender<ActorMsg>,
    join_handle: JoinHandle<()>,
}

impl ConversationRuntime {
    pub fn new() -> Self {
        let (sender, receiver) = mpsc::channel(5);
        let messages = Arc::new(Mutex::new(Vec::new()));
        let actor = Actor::new(receiver, messages.clone());
        let join_handle = tokio::spawn(async move { actor.run().await });
        ConversationRuntime {
            sender,
            messages,
            join_handle,
        }
    }

    pub fn api(&self) -> ConversationClient {
        ConversationClient {
            sender: self.sender.clone(),
            messages: self.messages.clone(),
        }
    }

    pub async fn shutdown(self) {
        // We drop the sender, to signal to the actor thread that it can no longer receive messages
        // and should stop.
        drop(self.sender);
        self.join_handle.await.unwrap();
    }
}

#[derive(Clone)]
pub struct ConversationClient {
    sender: mpsc::Sender<ActorMsg>,
    messages: Arc<Mutex<Vec<Message>>>,
}

impl Conversation for ConversationClient {
    async fn messages(self) -> impl Stream<Item = Message> + Send {
        let (request, response) = oneshot::channel();
        self.sender
            .send(ActorMsg::ReadMessages(request))
            .await
            .expect("Actor must outlive client.");
        let messages = response.await.unwrap();
        tokio_stream::iter(messages)
    }

    fn add_message(
        &self,
        NewMessage {
            id,
            sender,
            content,
        }: NewMessage,
    ) {
        let message = Message {
            id,
            sender,
            content,
            timestamp: SystemTime::now(),
        };
        let mut messages = self.messages.lock().unwrap();
        messages.push(message);
    }
}

/// A message as it is stored and represented as part of a conversation.
#[derive(Clone)]
pub struct Message {
    /// Sender generated unique identifier for the message. It is used to recover from errors
    /// sending messages. It also a key for the UI to efficiently update data structures then
    /// rendering messages.
    pub id: Uuid,
    /// Author of the message
    pub sender: String,
    /// Text content of the message. I.e. the actual message
    pub content: String,
    /// Timestamp when the message has been received by the server.
    pub timestamp: SystemTime,
}

/// A message as it is created by the frontend and sent to the server. It is not added to the
/// conversation yet, and does not have a timestamp.
#[derive(Deserialize, PartialEq, Eq, Debug)]
pub struct NewMessage {
    /// The uuid is generated by the client in order to be able to send messages idempotently.
    /// Wether they have been successfully received by the server and added to the conversation or
    /// not.
    pub id: Uuid,
    /// Author of the message
    pub sender: String,
    /// Text content of the message. I.e. the actual message
    pub content: String,
}

enum ActorMsg {
    ReadMessages(oneshot::Sender<Vec<Message>>),
}

struct Actor {
    messages: Arc<Mutex<Vec<Message>>>,
    receiver: mpsc::Receiver<ActorMsg>,
}

impl Actor {
    pub fn new(receiver: mpsc::Receiver<ActorMsg>, messages: Arc<Mutex<Vec<Message>>>) -> Self {
        Actor { receiver, messages }
    }

    pub async fn run(mut self) {
        while let Some(msg) = self.receiver.recv().await {
            self.handle_message(msg);
        }
    }

    pub fn handle_message(&mut self, msg: ActorMsg) {
        match msg {
            ActorMsg::ReadMessages(responder) => {
                let messages = self.messages.lock().unwrap().clone();
                // We ignore send errors, since it only happens if the receiver has been dropped. In
                // that case the receiver is no longer interested in the response, anyway.
                let _ = responder.send(messages);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use futures_util::StreamExt;

    #[tokio::test]
    async fn messages_are_added_and_read_in_order() {
        // Given
        let id_1: Uuid = "019c0ab6-9d11-75ef-ab02-60f070b1582a".parse().unwrap();
        let msg_1 = NewMessage {
            id: id_1.clone(),
            sender: "Alice".to_string(),
            content: "One".to_string(),
        };
        let id_2: Uuid = "019c0ab6-9d11-7a5b-abde-cb349e5fd995".parse().unwrap();
        let msg_2 = NewMessage {
            id: id_2.clone(),
            sender: "Bob".to_string(),
            content: "Two".to_string(),
        };
        let runtime = ConversationRuntime::new();
        let client = runtime.api();

        // When
        client.add_message(msg_1);
        client.add_message(msg_2);
        let mut messages = client.messages().await;

        // Then
        let first = messages.next().await.expect("First message should exist");
        assert_eq!(first.id, id_1);
        assert_eq!(first.sender, "Alice");
        assert_eq!(first.content, "One");

        let second = messages.next().await.expect("Second message should exist");
        assert_eq!(second.id, id_2);
        assert_eq!(second.sender, "Bob");
        assert_eq!(second.content, "Two");

        // Cleanup
        runtime.shutdown().await;
    }
}
